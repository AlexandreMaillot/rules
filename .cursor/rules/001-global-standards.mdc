---
description: APPLY global standards WHEN writing code or documentation TO ensure consistency and maintainability
globs: **/*
alwaysApply: false
---

# Global Standards

<version>1.0.0</version>

## Context
- These rules apply to all code and documentation in the project
- They establish fundamental principles for communication and code organization
- They ensure consistency across the entire codebase
- Everything MUST be written in English

## Requirements


## Examples

<example>
class LateFeeCalculationError extends BusinessError {
  constructor(internalMessage: string) {
    super({
      internal: internalMessage,
      user: "Le calcul des frais de retard a échoué : la durée ne peut pas être négative.",
      code: "LATE_FEE_NEGATIVE_DAYS"
    });
  }
}

// Business-focused comment in English
function calculateLateFees(daysOverdue: number): number {
  // Business rule: Fees are 0.50€ per day for the first 10 days,
  // then 1€ per day after that.
  if (daysOverdue < 0) {
    throw new LateFeeCalculationError("Negative days provided");
  }

  if (daysOverdue <= 10) {
    return daysOverdue * 0.5;
  }

  return (10 * 0.5) + ((daysOverdue - 10) * 1);
}
</example>

<example type="invalid">
// No business-focused comment
function calculateLateFees(daysOverdue) { // ❌ No type, should be `number`
  if (daysOverdue < 0) {
    throw "Invalid days"; // ❌ No structured exception, unclear error
  }

  if (daysOverdue <= 10) {
    return daysOverdue * 0.5;
  }

  return (10 * 0.5) + ((daysOverdue - 10) * 1);
}

try {
  const fee = calculateLateFees(-5);
} catch (error) {
  console.error(error); // ❌ No structured logging, raw string printed
}
</example>

## Critical Rules

<critical>
- NEVER mix languages in code or comments
- ALWAYS separate user-facing messages from internal system messages
- ALWAYS prioritize business domain clarity over technical implementation details
- ALWAYS document the business reason for complex code
</critical> 
