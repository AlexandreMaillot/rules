---
description: TOUJOURS utiliser await avec showDialog, showModalBottomSheet et autres méthodes de navigation asynchrones
globs: apps/*/lib/**/*.dart
alwaysApply: true
---

Principe:

- Les méthodes de navigation asynchrones Flutter retournent des Futures
- Utiliser `await` garantit l'ordre d'exécution et permet de récupérer le résultat (si présent)
- Sans `await`, le code continue immédiatement sans attendre la fermeture du dialogue
- Même sans valeur de retour, `await` est obligatoire pour garantir l'ordre d'exécution
- Cela peut causer des bugs de timing et empêcher la récupération de valeurs de retour

Règle absolue:

- OBLIGATOIRE : Toujours utiliser `await` devant `showDialog`, `showModalBottomSheet`, `showGeneralDialog`, etc.
- OBLIGATOIRE : Même si on n'utilise pas la valeur de retour, `await` est obligatoire pour l'ordre d'exécution
- OBLIGATOIRE : La méthode appelante doit être `async`
- OBLIGATOIRE : Vérifier `context.mounted` après un `await` si on utilise le contexte

Méthodes concernées:

- `showDialog<T>()` - Dialogues modaux
- `showModalBottomSheet<T>()` - Bottom sheets modaux
- `showGeneralDialog<T>()` - Dialogues personnalisés
- `showDatePicker()` - Sélecteur de date
- `showTimePicker()` - Sélecteur d'heure
- Toutes les méthodes de navigation qui retournent un `Future<T>`

Exemples interdits:

```dart
// ❌ showDialog sans await (même sans valeur de retour)
void _onSupprimer() {
  showDialog<void>(
    context: context,
    builder: (_) => const ConfirmationDialog(),
  );
  // Le code continue immédiatement, le dialogue peut ne pas être encore affiché
  _supprimer(); // Exécuté avant la fermeture du dialogue
}

// ❌ showModalBottomSheet sans await
void _onChoisirOption() {
  showModalBottomSheet<String>(
    context: context,
    builder: (_) => const OptionsSheet(),
  );
  // Impossible de récupérer le résultat
}
```

Exemples corrects:

```dart
// ✅ showDialog avec await et valeur de retour
Future<void> _onSupprimer() async {
  final confirme = await showDialog<bool>(
    context: context,
    builder: (_) => const ConfirmationDialog(),
  );
  
  if (!context.mounted) return;
  
  if (confirme == true) {
    _supprimer();
  }
}

// ✅ showDialog avec await SANS valeur de retour (await obligatoire quand même)
Future<void> _onAfficherInfo() async {
  await showDialog<void>(
    context: context,
    builder: (_) => const InfoDialog(),
  );
  
  // Le code attend la fermeture du dialogue avant de continuer
  if (!context.mounted) return;
  
  _apresFermetureDialogue();
}

// ✅ showModalBottomSheet avec await
Future<void> _onChoisirOption() async {
  final option = await showModalBottomSheet<String>(
    context: context,
    builder: (_) => const OptionsSheet(),
  );
  
  if (!context.mounted) return;
  
  if (option != null) {
    _traiterOption(option);
  }
}

// ✅ showDatePicker avec await
Future<void> _onChoisirDate() async {
  final date = await showDatePicker(
    context: context,
    initialDate: DateTime.now(),
    firstDate: DateTime(2000),
    lastDate: DateTime(2100),
  );
  
  if (!context.mounted) return;
  
  if (date != null) {
    _mettreAJourDate(date);
  }
}

// ✅ Dans un callback de widget
TextButton(
  onPressed: () async {
    final resultat = await showDialog<bool>(
      context: context,
      builder: (_) => const ConfirmationDialog(),
    );
    
    if (!context.mounted) return;
    
    if (resultat == true) {
      // Traiter le résultat
    }
  },
  child: const Text('Confirmer'),
)
```

Cas spéciaux:

- Même sans valeur de retour, `await` est OBLIGATOIRE : `await showDialog<void>(...)`
- L'`await` garantit que le code suivant s'exécute APRÈS la fermeture du dialogue
- Toujours vérifier `context.mounted` après un `await` si on utilise le contexte après
- Pour les dialogues de confirmation, utiliser `Future<bool?>` pour récupérer le choix de l'utilisateur
- Si on ignore la valeur de retour, utiliser `await showDialog<void>(...)` plutôt que `await showDialog(...)`

Bonnes pratiques:

- Toujours typer le Future retourné : `Future<T> showDialog<T>(...)`
- Utiliser des valeurs de retour explicites (bool, String, etc.) plutôt que void quand c'est pertinent
- Vérifier la nullité du résultat avant de l'utiliser
- Gérer les cas où l'utilisateur ferme le dialogue sans action (retourne null)

Conséquences du non-respect:

- Bugs de timing : code exécuté avant la fermeture du dialogue
- Impossible de récupérer les valeurs de retour
- Comportements imprévisibles et difficiles à déboguer
- Risque d'utiliser un contexte invalide après navigation
